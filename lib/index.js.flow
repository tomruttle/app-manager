// @flow

import { statuses, levels } from './constants';

export type RouteNameType = string;
export type SlotNameType = string;
export type FragmentNameType = string;
export type StatusType = $Values<typeof statuses>;
export type StatusLevelType = $Values<typeof levels>;

export type GetElementWindowType = { document: { querySelector(querySelector: string): ?Element } };
export type GetElementType = (container: Element, querySelector: string) => Promise<?Element>;
export type GetRouteNameFromResourceType = (resource: string) => ?RouteNameType | Promise<?RouteNameType>

export type StateAdditionsType = { [stateName: string]: any };
export type GetAdditionalStateType = (routeName: ?RouteNameType, resource: string) => StateAdditionsType;

export type LifecycleType = AsyncGenerator<true, boolean, boolean>;

type EventCallbackType = (...data: Array<any>) => any;

export type EventsType = {
  emit(eventTitle: string, ...data: Array<any>): void,
  on(eventTitle: string, callback: EventCallbackType): void,
  removeListener(eventTitle: string, callback: EventCallbackType): void,
}

export type OptionsType = {
  importTimeout: number,
  getRouteNameFromResource: GetRouteNameFromResourceType,
  getAdditionalState?: GetAdditionalStateType,
  getElement: GetElementType,
};

export type OverrideOptionsType = {
  importTimeout?: number,
  getRouteNameFromResource?: GetRouteNameFromResourceType,
  getAdditionalState?: GetAdditionalStateType,
  getElement?: GetElementType,
};

export type BaseRouteType = {
  path?: string,
  paths?: Array<string>,
  fragment?: FragmentNameType,
  fragments?: Array<FragmentNameType>,
}

export type RouteType = BaseRouteType & { name: RouteNameType };

export type RoutesMapType = { [routeName: RouteNameType]: RouteType };

export type BrowserStateType = {
  resource: string,
  eventTitle: string,
  title?: ?string,
  state?: ?Object,
};

export type StateType = {
  resource: string,
  eventTitle: string,
  prevRoute: ?RouteType,
  route: ?RouteType,
};

export type StateWithAdditionsType = StateType & StateAdditionsType;

export type StatusDetailsType = {|
  status: StatusType,
  level: string,
  message?: ?string,
|}

type BaseSlotType = {
  querySelector: ?string,
  getErrorMarkup?: (state: StateWithAdditionsType) => string | Promise<string>,
  getLoadingMarkup?: (state: StateWithAdditionsType) => string | Promise<string>,
};

export type SlotType = BaseSlotType & { name: SlotNameType };

export type SlotsMapType = { [slotName: SlotNameType]: SlotType };

type ScriptVersion5RouteType = {
  appPath?: string,
  appPaths?: Array<string>,
  fragment?: FragmentNameType,
  fragments?: Array<FragmentNameType>,
};

type ScriptVersion5StateWithAdditionsType = {
  event: ?string,
  resource: string,
  app: ScriptVersion5RouteType,
  prevApp: ?ScriptVersion5RouteType,
} & StateAdditionsType;

interface ScriptVersion4Type {
  version: 4;
  hydrate?: (container: Element, currentRoute: ScriptVersion5RouteType) => Promise<?void>;
  mount: (container: Element, eventTitle: ?string, currentRoute: ScriptVersion5RouteType) => Promise<?void>;
  unmount: (container: Element, eventTitle: ?string, currentRoute: ?ScriptVersion5RouteType) => Promise<?void>;
  onUpdateStatus?: (status: StatusType, currentRoute: ScriptVersion5RouteType) => Promise<?void>;
  onStateChange?: (eventTitle: ?string, currentRoute: ScriptVersion5RouteType) => Promise<?void>;
}

interface ScriptVersion5Type {
  version: 5;
  hydrate?: (container: Element, state: ScriptVersion5StateWithAdditionsType) => any;
  render?: (container: Element, state: ScriptVersion5StateWithAdditionsType) => any;
  unmount?: (container: Element, state: ScriptVersion5StateWithAdditionsType) => any;
  onUpdateStatus?: (statusDetails: StatusDetailsType, state: ScriptVersion5StateWithAdditionsType) => any;
  onStateChange?: (state: ScriptVersion5StateWithAdditionsType) => any;
}

interface ScriptVersion6Type {
  version: 6;
  hydrate?: (container: Element, state: StateWithAdditionsType) => any;
  render?: (container: Element, state: StateWithAdditionsType) => any;
  unmount?: (container: Element, state: StateWithAdditionsType) => any;
  onUpdateStatus?: (statusDetails: StatusDetailsType, state: StateWithAdditionsType) => any;
  onStateChange?: (container: Element, state: StateWithAdditionsType) => any;
}

export type LoadedScriptType = (ScriptVersion4Type | ScriptVersion5Type | ScriptVersion6Type);

type LoadScriptType = (state: ?StateType) => LoadedScriptType | Promise<LoadedScriptType>;

type GetMarkupType = (state: StateWithAdditionsType, ...otherArgs: Array<any>) => string | Promise<string>;

type BaseFragmentType = {
  slot?: SlotNameType,
  slots?: Array<SlotNameType>,
  loadScript?: LoadScriptType,
  getMarkup?: GetMarkupType,
};

export type FragmentType = BaseFragmentType & { name: FragmentNameType };

export type FragmentsMapType = { [fragmentName: FragmentNameType]: FragmentType };

export type ConfigType = {|
  routes: { [routeName: RouteNameType]: BaseRouteType },
  slots: { [slotName: SlotNameType]: BaseSlotType },
  fragments: { [fragmentName: FragmentNameType]: BaseFragmentType },
|};

export type OnErrorCallbackType = (err: Error) => void | Promise<void>;

export interface ScriptType {
  hydrate: (container: Element, state: StateWithAdditionsType) => Promise<void>;
  render: (container: Element, state: StateWithAdditionsType) => Promise<void>;
  unmount: (container: Element, state: StateWithAdditionsType) => Promise<void>;
  onStateChange: (container: Element, state: StateWithAdditionsType) => Promise<void>;
  onUpdateStatus: (statusDetails: StatusDetailsType, state: StateWithAdditionsType) => Promise<void>;
}

declare export default (config: ConfigType, overrideOptions?: OverrideOptionsType) => ScriptType;
