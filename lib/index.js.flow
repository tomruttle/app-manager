// @flow

import type AppManagerError from './utils/app-manager-error';
import { eventTitles, statuses, levels } from './constants';

export type AppNameType = string;
export type SlotNameType = string;
export type FragmentNameType = string;
export type EventTitleType = $Values<typeof eventTitles>;
export type StatusType = $Values<typeof statuses>;
export type StatusLevelType = $Values<typeof levels>;

type StateAdditionsType = { [stateName: string]: any };
type GetAppNameFromResourceType = (resource: string) => ?AppNameType;
type GetAdditionalStateType = (appName: AppNameType, resource: string) => StateAdditionsType;
type OnErrorType = (err: AppManagerError) => void;

export type OptionsType = {
  importTimeout: number,
  domCheckInterval: number,
  getAppNameFromResource: GetAppNameFromResourceType,
  getAdditionalState?: GetAdditionalStateType,
  onError: OnErrorType,
};

export type OverrideOptionsType = {
  importTimeout?: number,
  domCheckInterval?: number,
  getAppNameFromResource?: GetAppNameFromResourceType,
  getAdditionalState?: GetAdditionalStateType,
  onError?: OnErrorType,
};

export type BaseAppType = {
  appPath?: string,
  appPaths?: Array<string>,
  fragment?: FragmentNameType,
  fragments?: Array<FragmentNameType>,
}

export type AppType = BaseAppType & { name: AppNameType };

export type AppsMapType = { [appName: AppNameType]: AppType };

export type EventCallbackType = (...data: Array<any>) => any;
export type EmitterType = (eventTitle: EventTitleType, ...data: Array<any>) => void;
export type SubscriberType = (eventTitle: EventTitleType, callback: EventCallbackType) => void;
export type RemoveListenerType = (eventTitle: EventTitleType, callback: EventCallbackType) => void;

export type EventsType = {
  emit: EmitterType,
  on: SubscriberType,
  removeListener: RemoveListenerType,
}

export type BrowserStateType = {
  resource: string,
  title?: ?string,
  state?: ?Object,
  eventTitle?: ?mixed,
};

export type StateType = {
  event: ?string,
  prevApp: ?AppType,
  app: AppType,
  resource: string,
};

export type StateWithAdditionsType = StateType & StateAdditionsType;

export type GetStateType = () => ?StateWithAdditionsType;

export type StatusDetailsType = {|
  status: StatusType,
  level: string,
  message?: ?string,
|}

export type HistoryType = Object;

export interface ScriptVersion3Type {
  version: 3;
  hydrate(container: Element, history: HistoryType, currentApp: AppType): Promise<?void>;
  mount(container: Element, history: HistoryType, currentApp: AppType): Promise<?void>;
  unmount(container: Element, history: HistoryType, currentApp: AppType): Promise<?void>;
  onStateChange(history: HistoryType, currentApp: AppType): Promise<?void>;
}

export interface ScriptVersion4Type {
  version: 4;
  hydrate?: (container: Element, currentApp: AppType) => Promise<?void>;
  mount: (container: Element, eventTitle: EventTitleType, currentApp: AppType) => Promise<?void>;
  unmount: (container: Element, eventTitle: EventTitleType, currentApp: AppType) => Promise<?void>;
  onUpdateStatus?: (status: StatusType, currentApp: AppType) => Promise<?void>;
  onStateChange?: (eventTitle: EventTitleType, currentApp: AppType) => Promise<?void>;
}

export interface ScriptVersion5Type {
  version: 5;
  hydrate?: (container: Element, state: StateWithAdditionsType) => any;
  render?: (container: Element, state: StateWithAdditionsType) => any;
  unmount?: (container: Element, state: StateWithAdditionsType) => any;
  onUpdateStatus?: (statusDetails: StatusDetailsType, state: StateWithAdditionsType) => any;
  onStateChange?: (state: StateWithAdditionsType) => any;
}

export type LoadedScriptType = (ScriptVersion3Type | ScriptVersion4Type | ScriptVersion5Type);

export interface ScriptType {
  hydrate: (container: Element, state: StateWithAdditionsType) => Promise<void>;
  render: (container: Element, state: StateWithAdditionsType) => Promise<void>;
  unmount: (container: Element, state: StateWithAdditionsType) => Promise<void>;
  onUpdateStatus: (statusDetails: StatusDetailsType, state: StateWithAdditionsType) => Promise<void>;
  onStateChange: (state: StateWithAdditionsType) => Promise<void>;
}

type BaseSlotType = {
  querySelector: ?string,
  errorMarkup?: string,
  loadingMarkup?: string,
};

export type SlotType = BaseSlotType & { name: SlotNameType };

export type SlotsMapType = { [slotName: SlotNameType]: SlotType };

export type LoadScriptType = (state: StateType) => Promise<LoadedScriptType>;

type GetMarkupType = (state: StateWithAdditionsType, ...otherArgs: Array<any>) => string | Promise<string>;

type BaseFragmentType = {
  slot?: SlotNameType,
  slots?: Array<SlotNameType>,
  loadScript?: LoadScriptType,
  getMarkup?: GetMarkupType,
};

export type StateChangeType = Promise<void>;

export type FragmentType = BaseFragmentType & { name: FragmentNameType };

export type FragmentsMapType = { [fragmentName: FragmentNameType]: FragmentType };

export type PageMapType = { [slotName: SlotNameType]: FragmentNameType };

export type PageDiffType = { unmount: PageMapType, mount: PageMapType, update: PageMapType };

export type ConfigType = {|
  apps: { [appName: AppNameType]: BaseAppType },
  slots: { [slotName: SlotNameType]: BaseSlotType },
  fragments: { [fragmentName: FragmentNameType]: BaseFragmentType },
|};

declare export default (config: ConfigType, events: EventsType, options?: OptionsType) => {
  getState(): StateWithAdditionsType,
  getRunningStateChange(): ?StateChangeType,
}
